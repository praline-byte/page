---
layout: post
title: 手摸手搞搜索（二）—— 检索原理与B+树
categories: 搜索引擎 数据结构
description: 
keywords: 搜索引擎 boltdb B+树
---

# 检索到底是什么

在上一章中，我们创办了属于自己的公司，靓仔文化有限公司，因经营不善，濒临破产。

>[手摸手搞搜索（一）](https://praline-byte.github.io/page/2020/11/16/ch1-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/)

原因是靓仔太多，租用的凡尔纳黄金大厅和土拨鼠大厅成本高昂，而每一次商业业务都处理的非常缓慢，入不敷出。

于是我们今天紧急召开一次董事大会，决定进行大刀阔斧的改革。

## 改革！改革！

改革的第一项就是：退租黄金大厅，节约成本。

创业公司要有吃苦精神，放弃富丽堂皇的大厅，在地上挖池子。

来一个靓仔，就向池子里丢，由于不用考虑动作姿势等限制条件，所以这个过程非常块。

![](/images/posts/B+树_images/大池子-1.png)

当一个池子满了的时候，就再挖一个池子向里丢。

来报名的靓仔络绎不绝，很快我们就蓄满了许多个大池子。

![](/images/posts/B+树_images/大池子-2.png)

通过这个手段我们解决了昂贵的成本问题，但是没有解决业务处理问题，因为我们找到符合业务要求的靓仔们，还是要走很多路，要在
每个大池子面前都喊一遍。

而在我司业务蓬勃发展中，加入我司的靓仔越来越多，池子也越来越多。极端情况下要遍历所有的大池子，显然这种方式和"凡尔纳黄金大厅"一样都是超级耗时的。

这时候我们想到在第一张中介绍过的有序数据和二分查找的方式可以极大的提升检索效率，这个有效的经验我们现在还可以借用吗？不急，我们接着往下走。

## 索引

我们在上一章说得有序数组也好，有序链表也好，本质上都可以用来当作"索引"。

**什么是索引？**

一句话简单来说，索引是一种为了提高数据查询效率的数据结构，就像书的目录一样。我们为了加速寻找靓仔们，也得用索引。
>一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。

三种常用于索引，也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

其中有序数组的概念，我们在上一章中介绍过，哈希表也在上一章**第一次尝试**部分隐约透露过。

本章节我们接着说说搜索树的代表 B+树。

# B+ 树的生成

## 页内数据排列

在上一章中我们知道，有序的数据可以用二分查找，效率非常高。

所以我们靓仔文化有限公司明文规定：
>**靓仔们必须根据自己的身份编号，有序入池**
>
>**下一个池子的所有编号必须比上一个池子大**

我们假设每个大池子只能存放三个靓仔，并且按照规定向池子中丢进三个靓仔：

![](/images/posts/B+树_images/大池子-3.png)

## 页分裂

此时再丢进一个靓仔，由于一个大池子只能站得下三个靓仔，不得不再搞一个大池子。

1.插入的是最大值
> 6号鲁智深
> 
> 直接丢在新池子

![](/images/posts/B+树_images/插入鲁智深.png)

2.插入的是中间值
> 4号上官婉儿
>
> 把5号胜李逵揪出来，丢到"大池子-7"中

![](/images/posts/B+树_images/插入上官婉儿.png)

这个过程表明了在向大池子丢靓仔的过程中，我们必须让一些靓仔腾转挪移来始终保证这个状态一直成立：**下一个池子所有靓仔的编号必须比上一个池子的大。**。

> 为了公司业务合法合规，顺利上市，之后文中的部分地方，我们用黑话**数据页**比作大池子，用**记录**比作靓仔。

这个过程我们也可以称为**数据页的分裂**。

## 页目录

继续扔进多个靓仔后，可能是这样的效果

![](/images/posts/B+树_images/多个池子.png)

因为这些大池子在地理位置上可能并不挨着，所以如果想从这么多大池子中根据编号快速定位靓仔，就需要给它们做个目录，每个大池子对应一个目录项，每个目录项包括下边两个部分：
>池子中靓仔的编号的最小值
>
>池子编号

![](/images/posts/B+树_images/目录页-大池子.png)

所以到目前为止，我们总结一下当前的检索方式

**在一个大池子中查找**

使用二分法快速定位

**在很多个大池子中查找**

1. 根据目录页定位到靓仔所在的池子
2. 在一个大池子中使用二分法快速定位

>为什么池子编号看起来这么随意？
>
>存储引擎通常使用页来作为管理存储空间的基本单位，业内存储空间连续，页与页之间可能空间不连续

## 目录页增长

那如果表中的数据太多，以至于一个目录页不足以存放所有的目录记录（假设只能存储4条目录），该咋办？

当然是再多整一个存储目录项记录的页。

![](/images/posts/B+树_images/目录页增长-1.png)

从图中可以看出，我们丢进甄姬之后需要两个新的数据页：

1. 存放该靓仔的"大池子-3"
2. 存放"大池子-3"目录的"目录页-2"

到目前为止，我们更新一下当前的检索方式

1. 确定目录页
2. 根据目录页定位到靓仔所在的池子
3. 在一个大池子中使用二分法快速定位

在这个查询步骤的第1步中我们需要定位目录页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多目录页。

## B+树示意图

那我们怎么根据编号快速定位一个目录页呢？

其实也简单，为这些目录页再生成一个更高级的目录页，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据。

所以现在各个页的示意图就是这样子

![](/images/posts/B+树_images/B+树示意图.png)

随着表中记录的增加，这个目录的层级会继续增加

这玩意儿像不像一个倒过来的树呀，上头是树根，下头是树叶。

其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是B+树。

一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）。

>假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：
>
>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。
>
>如果B+树有2层，最多能存放1000×100=100000条记录。
>
>如果B+树有3层，最多能存放1000×1000×100=100000000条记录。
>
>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录

# 实际中树的生成过程

根页面万年不动窝

我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储靓仔的大池子都画出来，然后接着画目录页，实际上B+树的形成过程是这样的：

1. 每当创建一个B+树索引的时候，都会为这个索引创建一个根节点页面。
2. 随后向表中插入记录时，先把用户记录存储到这个根节点中。
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。
这时新插入的记录根据键值的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

>这个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们建立一个索引，那么它的根节点的页号便会被记录到某个地方，
>然后凡是存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

# 本章小结

在本章中我们介绍了 b+树这种适用范围非常广的索引结构。

目前我们的存储引擎，数据还放在内存里，并没有持久化到磁盘上，意味着电脑一旦重启将失去所有数据，这将对我们的公司业务带来毁灭性的冲击。

下一章中我们将介绍一个基于 b+树轻量级的存储层实现，并由此来升级改造我们的搜索引擎。

