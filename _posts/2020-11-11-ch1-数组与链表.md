---
layout: post
title: 手摸手搞搜索（一）—— 靓仔文化有限公司
categories: 搜索引擎 数据结构
description: 
keywords: 搜索引擎 数据结构 哈希表 有序数组
---

## 业务背景
天气晴朗，万合天宜

今天是一个适合搞事情的日子，我们创办一家公司，公司名字我替大家想好了**靓仔文化有限公司**，大家都是股东。

我们公司的愿景就是，把世界上所有的靓仔都招聘进来，招聘靓仔干什么，这不重要先不考虑。

我们先看下招聘靓仔的过程中会发生什么。

## 招聘靓仔

开门大吉！

营业第一天就有非常多的靓仔前来报名，在领取靓仔编号，登记完姓名后，靓仔们就来到一层凡尔纳黄金大厅休息。

前来报名的人络绎不绝，很快大厅就挤满了人，熙熙攘攘好不热闹。

![](/images/posts/ch1-数组与链表_images/凡尔纳金色大厅1.png)

这时候某知名国际大品牌需要我们提供1000名 18岁的靓仔参加商演。

这可麻烦了，在占地百万平方公里的凡尔纳大厅，要找齐这1000名靓仔，可真是不容易。

气喘吁吁！在挨个询问完之后，在微信运动步数5万步之后，终于找齐了这些靓仔，赚到了第一笔钱，打工人打工泪。

晚上下班做完大保健，拍屁股一想，决定不能这么搞，要想想办法了。

## 第一次尝试

有了第一天的辛酸，我们计划把凡尔纳大厅划分为东西两个方位，让20岁以下的靓仔去东边，20岁以上的靓仔去西边。

![](/images/posts/ch1-数组与链表_images/凡尔纳金色大厅2.png)

这样划分之后，根据需求我们可以立马知道他们在东西哪个方位，找靓仔的时间缩短了一半，再也不用被动去做大保健，每天都很开心。

因为我们划分了大厅不同位置给不同年纪的靓仔们，所以此时靓仔报道，得知他们的年纪后，也需要让他们去指定位置呆着（20岁以下去东边，20岁以上去西边）。

问题来了，20岁以下的靓仔越来越多，直到有一天，凡尔纳金色大厅的东部区域撑爆，再也挤不下了，怎么办？

![](/images/posts/ch1-数组与链表_images/大厅3.png)

这时候不得不花重金去租用土拨鼠大厅，细心的你会发现，不对呀，凡尔纳大厅明明还有很多空间能塞得下，为什么要浪费钱去租用别的大厅呢？

我们当然有很多办法可以充分利用凡尔纳大厅，比如改变一下规则，重新划分以下区域等等，但是不着急这是之后的事情，为了故事发展，这个土拨鼠大厅我们必须就得租，这个钱就得花了。

![](/images/posts/ch1-数组与链表_images/大厅4.png)

这时候再来报名的靓仔，如果是20岁以下并且凡尔纳大厅东部没有位置时，我们就可以让他去土拨鼠大厅报道。

通过这一系列的操作我们可以知道，搜索的本质其实就是**利用存储空间**（凡尔纳大厅和土拨鼠大厅），有效的**组织数据**（靓仔们），达到**快速检索**的业务需求（尽可能短的查找时间）。

当然我们目前的处理方法还非常的简单粗暴，随着之后业务越来越复杂，我们面临的问题也越来越棘手。没关系，到时候我们一起解决它！

既然搜索就是将我们所需要的数据，从存储数据的地方高效取出。那么不同的存储方式，就会导致不同的检索效率，所以研究数据结构的存储特点对检索效率的影响就至关重要了。

在本章中我想先向你介绍，计算机存储中最基本的两个数据结构**数组**和**链表**，它是今后构建一切数据结构的基础。

## 数组和链表

![](/images/posts/ch1-数组与链表_images/计算机中的空间.png)

我们在向计算机存储数据时，需要申请空间，这时候会有两种情况

1. 申请成功，存在连续的空间，如图中需要申请两个连续的小格子，计算机刚好可以完整的给我们

2. 申请失败，不存在连续的空间，如图中需要申请三个连续的小格子，计算机没有合适的空间给我们

从空间是否连续这个角度出发，我们可以归纳出计算机中两种最基础的数据结构：数组和链表。

![](/images/posts/ch1-数组与链表_images/数据与链表1.png)

数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，都不外乎是这两者的结合和变化。

> 连续空间的好处：可以通过连续空间的下标直接的到空间的值。而不连续空间如链表，则需要通过头节点一个一个找下去

我们来看一下两种数据结构的检索效率。

如果数据是无序的话，无论是链表还是数组，我们都需要从头开始遍历，直到找到目标，显然这在数据量很大的情况下，是非常耗时的。

![](/images/posts/ch1-数组与链表_images/查找6.png)

而如果把数据按照有序存储，使用二分查找，也就是折半查找时，性能就是对数级别了。

## 二分查找

二分查找会从有序数组的中间开始查找，如果找到了就返回结果。

如果没找到，会比较中间值和查找值的大小，如果查找值比中间值大，则在右半部分数据查找，如果比中间值小则在左半部分查找。

![](/images/posts/ch1-数组与链表_images/二分查找.png)

由此可见合理组织数据，的确可以提高检索效率。

我们在这个例子中用的是有序数组的二分查找，那有序链表可以达到这样的效率吗？

答案是达不到，我们在前面说过，链表需要从头部节点一个一个遍历，不能像数组一样直接通过下标获得结果，所以链表的检索能力是偏弱的。

但是任何事物都有两面性，链表在存储时的性能却是数组的爸爸。

## 链表的优点

我们前面说过要通过二分查找提高效率的前提是，数组要有序。所以每当数据增加的时候，我们都要满足这个原则。

![](/images/posts/ch1-数组与链表_images/数组移动.png)

在有序的数组中插入一个元素，为了保证**数组有序**，我们就需要将数组中排在这个元素后面的元素，全部顺序后移一位，在数据很大的数组上这个代价非常高。

而链表的代价则低到可以忽略，只需要调整前后链表的指针。

![](/images/posts/ch1-数组与链表_images/链表插入.png)

我们在下一章中将结合二者的优点，介绍一个更为强大的结构，搜索树。

## 搜索引擎的第一行代码

我们知道搜索引擎需要存储结构存储数据（我们先使用数组存储），除此之外应该还需要两种操作，索引和检索。

所以我们搜索引擎的雏形是这样：

![](/images/posts/ch1-数组与链表_images/搜索引擎1.png)

只说不练假把式，有了理论指导，接下来我们看一下在搜索引擎中如何实现。

这是我们**手摸手搞搜索**的第一行代码，使用 go 语言来实现。

>语言只是一种解决问题的工具，重要的是原理，底子摸清楚了用什么语言实现都行，比如 java 的 lucene，rust 的 rucene。

这里我们使用 go 来支撑课程的原因主要是入门门槛非常低，性能还不错，这样可以把精力集中在搜索引擎的原理上。

如果要系统的入门 go，我推荐这个
>https://github.com/unknwon/the-way-to-go_ZH_CN

也可以跟着我们故事发展，在实践中，碰到什么我们消化什么。

世界上最简单的搜索引擎可以用两个函数来实现，这两个函数分别实现**索引数据**和**检索数据**两个功能。
```
// 声明存储结构
var	store = make([]string, 0)

// 索引数据
func Index(data string) {
	store = append(store, data)
}

// 检索数据
func Search(query string) string {
	for _, name := range store {
		if name == query {
			return name
		}
	}
	return ""
}
```
>代码可以在 [https://github.com/praline-byte/search-engine](https://github.com/praline-byte/search-engine) 获取最新。

1. 第一步我们声明了一个存储结构 store，用于存放数据。
```
var	store = make([]string, 0)
```

2. 第二步定义索引方法，不断的将数据 data，追加到存储结构 store 中。
```
func Index(data string) {
	···
}
```

3. 第三步定义检索方法，遍历存储结构 store，寻找符合目标条件的数据。
```
func Search(query string) string {
	···
}
```

>代码中的 GO
>
>这段代码中设计了 func var make append return 等这几个 go 中的关键字。
>
>以及 string 这一基本数据类型，和 for-range 循环语句。
>
>我们在番外篇中详细说明。

在 GoLand 中运行 search_engine_v1_test.go
```
=== RUN   TestSearchEngineV1
    TestSearchEngineV1: search_engine_v1_test.go:14: 索引了数据:【程咬金】
    TestSearchEngineV1: search_engine_v1_test.go:14: 索引了数据:【孙尚香】
    TestSearchEngineV1: search_engine_v1_test.go:14: 索引了数据:【安琪拉】
    TestSearchEngineV1: search_engine_v1_test.go:20: 检索:【程咬金】
    TestSearchEngineV1: search_engine_v1_test.go:22: 检索结果:【程咬金】
--- PASS: TestSearchEngineV1 (0.00s)
PASS
```

it work！

## 本章小结

我们成立了一家公司：靓仔文化有限公司。

1. 通过招聘靓仔和寻找靓仔的过程，说明了搜索的基本流程。
2. 介绍了最基本的数据结构数组和链表。
3. 实现了搜索引擎第一版架构图和代码。

在下一章中，我们靓仔文化有限公司业务将继续升级，满足业务需求的同时我们将介绍搜索的本质——索引，及 B+树的实现原理。





