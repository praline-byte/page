---
layout: post
title: 搜索引擎远离与实现（二）—— B+树
categories: 搜索引擎 数据结构
description: 
keywords: 搜索引擎 数据结构 b+树
---


# 检索到底是什么

线性结构与非线性结构检索

需要使用例子。引出数组和链表 （分享时不用这么基础，直接从数据和链表讲起）
报名表，
"我想问一下我表舅秦大壮，有没有来报名过"

提升检索效率的第一个办法就是，通过排序算法转为有序数据集，再通过检索算法如二分查找来完成高效检索

数组需要连续的存储空间，检索效率非常高，但存储时涉及数据的复制移动，成本很大
链表可以申请不连续的空间，通过指针按顺序将这些空间串联起来，存储时仅涉及xxx，效率非常高，但是检索慢

数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，都不外乎是这两者的结合和变化


提高读写效率的数据结构

为了提高查询效率，我们使用了索引

索引
一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”
三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。
不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
图--
缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。哈希表这种结构适用于只有等值查询的场景

有序数组在等值查询和范围查询场景中的性能就都非常优秀，用二分法就可以快速得到，但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高

搜索树，由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中

---


# B+ 
查找，范围查找，插入，分裂，平衡

把记录存放在页中

页和记录的关系示意图
![](/images/B+树_images/页和记录的关系.png)

**在一个页中查找**

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以使用二分法快速定位

**在很多页中查找**
大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1.定位到记录所在的页
2.从所在的页内中二分查找相应的记录 

当页的数量很多的时候，如何组织页之间的关系，决定了检索的效率

1. 双向链表，极端情况下要遍历所有的数据页，显然这种方式是超级耗时的，比如在祖国人民中查找同名的人

（ps：页中增加 页的最小记录和最大纪录 有利于提升检索效率）

为了故事顺利发展，我们假设每个页只能存放三条记录，并且向页中插入了三条记录，这些记录按照索引值的大小串联成一个单向链表

![](/images/B+树_images/0a5b2f6b.png)

此时再插入一条记录，由于一个页只能存放三条记录，此时不得不再分配一个页

1.插入的是最大值

2.插入的是中间值
![](/images/B+树_images/插入中间值记录的移动.png)

**页分裂**
这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为页分裂。

继续插入多条记录后，可能是这样的效果

![](/images/B+树_images/插入多条记录后页情况.png)

因为这些16KB的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：

页的用户记录中最小的主键值，我们用key来表示。
页号，我们用page_no表示。

为 页 做目录
![](/images/B+树_images/为页做目录.png)

以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为20的记录，具体查找过程分两步：

先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 < 20 < 209），它对应的页是页9。
再根据前边说的在页中查找记录的方式去页9中定位具体的记录

InnoDB是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。

我们时常会对记录进行增删，假设我们把页28中的记录都删除了，页28也就没有存在的必要了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意


所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB怎么区分一条记录是普通的用户记录还是目录项记录呢？别忘了记录头信息里的record_type属性，它的各个取值代表的意思如下：

0：普通的用户记录
1：目录项记录
2：最小记录
3：最大记录

**innodb 与 boltdb 的区别**

![](/images/B+树_images/innodb的目录项页.png)

innodb中记录的结构
![](/images/B+树_images/innodb中记录的结构.png)

那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，该咋办

当然是再多整一个存储目录项记录的页

**目录页的增长**
![](/images/B+树_images/目录页的增长.png)


从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

为存储该用户记录而新生成了页31。

因为原先存储目录项记录的页30的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的页32来存放页31对应的目录项。

此时的查找过程为
1.确定目录项记录页
2.通过目录项记录页确定用户记录真实所在的页
3.在真实存储用户记录的页中定位到具体的记录

在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？其实也简单，为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子

![](/images/B+树_images/多级目录.png)

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述

![](/images/B+树_images/b+树的描述图.png)


这玩意儿像不像一个倒过来的树呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是B+树

为啥叫`B+`呢，`B`树是啥？我们后面在说明

一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录

假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。

如果B+树有2层，最多能存放1000×100=100000条记录。

如果B+树有3层，最多能存放1000×1000×100=100000000条记录。

如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录

**实际中 innodb 树的生成过程**

根页面万年不动窝
我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：

每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。

随后向表中插入用户记录时，先把用户记录存储到这个根节点中。

当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

这个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。







