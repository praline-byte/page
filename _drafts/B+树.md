---
layout: post
title: 搜索引擎原理与实现（二）—— B+树
categories: 搜索引擎 数据结构
description: 
keywords: 搜索引擎 数据结构 b+树
---

# 检索到底是什么

业务背景：靓仔文化有限公司

想象我们有一些个存放靓仔的大池子，来一个靓仔，就向池子里丢，由于不用考虑动作姿势等限制条件，所以这个过程非常块。

![](images/posts/B+树_images/大池子-1.png)

当一个池子满了的时候，就向另一个池子里丢。

来报名的靓仔络绎不绝，很快我们就蓄满了许多个大池子。

![](images/posts/B+树_images/大池子-2.png)

目前为止，公司业务运作良好。

这时候有一个小孩来前台问："我想找一下我表舅秦大壮"。

为了寻找"秦大壮"不得不在每个大池子面前都喊一遍，在我司业务蓬勃发展中，加入我司的靓仔越来越多，池子也越来越多。极端情况下要遍历所有的大池子，显然这种方式是超级耗时的。

这时候**索引**登场了。

一句话简单来说，索引一种是为了提高数据查询效率的数据结构，就像书的目录一样。
>一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。
>
>同样，对于数据库的表而言，索引其实就是它的"目录"。

三种常见，也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。
* 哈希表是一种以键值存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。
   
  
    不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的方法是，拉出一个链表或者开放寻址。
        
    缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。哈希表这种结构适用于只有等值查询的场景。
    

* 有序数组在等值查询和范围查询场景中的性能就都非常优秀，用二分法就可以快速得到，但是，在需要更新数据的时候就麻烦了，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
如果记录的更新非常频繁，就需要有序链表了。


    数组和链表分别代表了连续空间和不连续空间的最基础的存储方式，它们是线性表的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，都不外乎是这两者的结合和变化
                                                                                            
    数组需要连续的存储空间，检索效率非常高，但存储时涉及数据的复制移动，成本很大
                               
    链表可以申请不连续的空间，通过指针按顺序将这些空间串联起来，存储时仅涉及插入节点的指针移动，存储效率非常高，但是检索效率不高


* 搜索树，由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中

# B+树

为了加快寻找"秦大壮"，使故事继续发展，作为董事长的我们，需要制定一些规定，规定靓仔丢进大池子的方式。

## 页内数据排列

在**检索到底是什么**我们知道，有序的数据可以用二分查找，效率非常高。

所以我们靓仔文化有限公司明文规定：
>**靓仔们必须根据自己的身份编号，有序入池**
>
>**下一个池子的所有编号必须比上一个池子大**

我们假设每个大池子只能存放三个靓仔，并且按照规定向池子中丢进三个靓仔：

![](images/posts/B+树_images/大池子-3.png)

## 页分裂

此时再扔进一个靓仔，由于一个大池子只能站得下三个靓仔，不得不再搞一个大池子。

1.插入的是最大值
> 6号鲁智深
> 
> 直接丢在新池子

![](images/posts/B+树_images/插入鲁智深.png)

2.插入的是中间值
> 4号上官婉儿
>
> 把5号胜李逵揪出来，丢到"大池子-7"中

![](images/posts/B+树_images/插入上官婉儿.png)

这个过程表明了在向大池子丢靓仔的过程中，我们必须让一些靓仔腾转挪移来始终保证这个状态一直成立：**下一个池子所有靓仔的编号必须比上一个池子的大。**。

> 为了公司业务合法合规，顺利上市，之后文中的部分地方，我们用黑话**数据页**比作大池子，用**记录**比作靓仔。

这个过程我们也可以称为**数据页的分裂**。

## 页目录

继续扔进多个靓仔后，可能是这样的效果

![](images/posts/B+树_images/多个池子.png)

因为这些大池子在地理位置上可能并不挨着，所以如果想从这么多大池子中根据编号快速定位靓仔，就需要给它们做个目录，每个大池子对应一个目录项，每个目录项包括下边两个部分：
>池子中靓仔的编号的最小值
>
>池子编号

![](images/posts/B+树_images/目录页-大池子.png)

所以到目前为止，我们总结一下当前的检索方式

**在一个大池子中查找**

使用二分法快速定位

**在很多个大池子中查找**

1. 根据目录页定位到靓仔所在的池子
2. 在一个大池子中使用二分法快速定位

>为什么池子编号看起来这么随意？
>
>存储引擎通常使用页来作为管理存储空间的基本单位，业内存储空间连续，页与页之间可能空间不连续

##目录页的增长

那如果表中的数据太多，以至于一个目录页不足以存放所有的目录记录（假设只能存储4条目录），该咋办？

当然是再多整一个存储目录项记录的页。

![](images/posts/B+树_images/目录页增长-1.png)

从图中可以看出，我们丢进甄姬之后需要两个新的数据页：

1. 存放该靓仔的"大池子-3"
2. 存放"大池子-3"目录的"目录页-2"

到目前为止，我们更新一下当前的检索方式

1. 确定目录页
2. 根据目录页定位到靓仔所在的池子
3. 在一个大池子中使用二分法快速定位

在这个查询步骤的第1步中我们需要定位目录页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多目录页。

##B+树的生成

那我们怎么根据编号快速定位一个目录页呢？

其实也简单，为这些目录页再生成一个更高级的目录页，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据。

所以现在各个页的示意图就是这样子

![](images/posts/B+树_images/B+树示意图.png)

随着表中记录的增加，这个目录的层级会继续增加

这玩意儿像不像一个倒过来的树呀，上头是树根，下头是树叶。

其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是B+树。

一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）。

>假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：
>
>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。
>
>如果B+树有2层，最多能存放1000×100=100000条记录。
>
>如果B+树有3层，最多能存放1000×1000×100=100000000条记录。
>
>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录

**实际中树的生成过程**

根页面万年不动窝

我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储靓仔的大池子都画出来，然后接着画目录页，实际上B+树的形成过程是这样的：

1. 每当创建一个B+树索引的时候，都会为这个索引创建一个根节点页面。
2. 随后向表中插入记录时，先把用户记录存储到这个根节点中。
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。
这时新插入的记录根据键值的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

>这个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们建立一个索引，那么它的根节点的页号便会被记录到某个地方，
>然后凡是存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

